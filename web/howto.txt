How-To 


Importing the Library

In order to use our library, you must first install and import it.

For instructions on how to ist the Hermes library, see (*put in link here*) index.html.

To import the library, in Processing go to Sketch -> Import Library... > Hermes. This should place a number of statements the top of your sketch that look like:

(*format to look like Processing*)
import src. ...;


The Template: Explained

Every Processing sketch you write that makes use of Hermes, will contain a few specific lines of code. Go to (*insert link*) in order to see and download the template. 

The first block of code consists of several "import" statements. These allow you to use the library (as explained above).

The next block has the title (in comments) CONSTANTS. You should use this space to declare any variables you want to use in your code, and be able to change easily. Setting the WINDOW_WIDTH and WINDOW_HEIGHT variables set the initial dimensions of the Processing frame as it plays.

The next three lines are specific to our framework and are the basis of every sketch you will write. Let us explain each of them:

World: In our framework, the World is the all-knowing entity. In other words, it *needs* to know about everything you want to draw, update, and interact. 

Camera: The Camera is responsible for actually drawing to the screen. For the most part, the World will take care of telling the Camera what to draw, and the Camera will draw it. The power of our Camera is that it is dynamic. It can move through the World, drawing only the relevant parts at a time. 

It also allows you to define world coordinates that are abstract and independent from screen coordinates. For example, say in your game Billy the Cowboy is 1000 miles north of the gold mine and you want to show both of them on screen at once, don't get a bigger screen! The Camera can handle converting from World coordinates to screen coordinates. You can set the Camera up to draw Billy at (50, 100) and the gold mine at (50, 400). We will explain how to set the Camera's dimensions in your World below.

PostOffice: The PostOffice allows your game to communicate with the outside world. Input can come from the mouse or keyboard or anything on the network using the OpenSoundControl (OSC) protocol. Output can be sent to the network using OSC. OSC is a protocol that makes it easy to send information such as floats, integers, or strings over a network.

It is VERY important that you handle all of your outside-world interactions through our PostOffice (INCLUDING mouse and keyboard input). Do NOT use Processing's built-in mouseX etc. There are very important thread-related issues behind this.

The next block of code gives you a template of a Being.

Being: Every entity that exists in your World that has shape, can interact with other entities, and needs to get drawn must be a Being. You define a class of Beings by extending the Being abstract class from our framework, as shown here. The Being constructor takes a Shape object and sets the Being's underlying Shape and position. See (*link*)Shape documentation on how to create Shape objects. All of your beings must implement the draw() method. VERY IMPORTANT: Our World will take care of translating to the Being's position (as stored in Shape), so the draw() method must assume that the coordinate system is set at the Being's position. For example, imagine you have made a BeachBall Being whose underlying Shape is a Cirrcle and is currently positioned at (40, 80) and always has a width and height 30. The BeachBall's draw method should read : ellipse(0, 0, 30 , 30) in order to draw that circle centered at (40, 80). Recall that the World will translate to the BeachBall's position (40, 80), then call the BeachBall's draw() method there (treating its position as (0, 0)).


The next block of code shows you where to define your custom Groups, if you need them.

Groups: It is often handy to group Beings together and apply the same thing to all of them at once. Groups allow you to do this. You can make a new Group in any of three ways: use the framework's Group class to make a Group for which we set the underlying data structure, use the GenericGroup class to provide your own preferred datastructure, or define your own custom Group classes (that must extend Group or GenericGroup) that can be more elaborate.

Interactors: In order for your Beings to interact, you need to give the World rules by which they will interact. Two kinds of objects help you do this: Interactors and Interactions. Every type of interaction between two Groups, and Group and a Being, or two Beings must be registered with the World, using the registerInteraction method. This method takes an Interaction object. This object gets constructed with the Beings/Groups that wil interact, and an Interactor that gives the rules governing the interaction.

The MyInteractor class gives a template for how to write an Interactor. The detect method should return a boolean, indicating whether two Beings have interacted, and the handle method should do whatever should be done when they have interacted.

If you register an Interaction between two Groups of Beings, our framework handles running through both of the Groups checking for and handling interactions between each of the appropriate members.

Finally, something familiar! The rest of the code is Processing's setup() and draw() methods. It is important to include all of these lines in every sketch you make using Hermes. We will run through each line now:

void setup() {
	size(WINDOW_WIDTH, WINDOW_HEIGHT); 
This should be familiar. Set the size of the PApplet.

	Hermes.setPApplet(this);
This saves a reference to the PApplet in a common place, accessible to all of our and your code. It may come in handy for getting information about the PApplet and using Processing's built-in functions.

	_camera = new Camera();
	_postOffice = new PostOffice(8080, 8000);
	_world = new World(_postOffice, _camera);
Instantiate your Camera, PostOffice, and World objects. Notice that the World takes references to the Camera and PostOffice objects - this is what allows it to get messages from and send messages to the PostOffice and tell the Camera which Beings to draw. The numbers in the PostOffice constructor tell it which port on your computer to listen on for messages. If you are not using the network OSC capabilities, don't worry about this argument, in fact you can just leave them out and give an empty constructor (you may want to do this if you are only getting input from the mouse and keyboard). If you are using this port address already, you can put in a different address. Just be sure that both numbers are over 1000. (*maybe put link here for some wkipedia thing on howto choose these*)

	//IMPORTANT: put all other setup here        
        _world.start(); // this should be the last line in setup() method
These lines appear in this order for an excellent reason. Everything you write before _world.start(); gets done before any thing gets run -- before any updates take place or any interactions are checked for and handled. Writing _world.start(); tells our library to actually start doing all of these things you have set-up. 

Here is a more technical explanation of why: we have designed the framework to be multi-threaded to improve performance. The mechanics of the game run on the World's thread and the drawing is all done on Processing's draw thread. We have taken care to make sure it is thread-safe. This is why it is so important that you do all mouse, keyboard messages through our PostOffice. If you use mouseX and other similar built-in things, we can't guarantee that it will be thread-safe.

If you did not understand the above paragraph, do not worry about it. All you need to know is that all of your other set-up (ex creating Beings, registering Interactions, etc) that you want done before the mechanics actually start running need to go before _world.start(); and _world.start(); must be the last line in the setup() method.
}

void draw() {

	_camera.draw();
This tells the Camera to start drawing. Now the game mechanics are running and the Camera is drawing. Congrats!

}



