There are two main parts of our library: our game framework: which is basically our structure for creating bodies and a game loop and setting the rules by which bodies interact with each other and the outside world, and our library code, which has classes we've written for handling collision detection and response, sprite animation and graphical effects, timers, and other structures that we think our users will likely need.

The most basic unit of our framework is the Being, which is the representation of an object in the game. Being have their own draw method, which determines exactly how it is drawn to the screen, and coordinates. Obviously, user implementations of bodies will have many other parameters. The basic idea of beings, however, is that beings are "dumb", that is, they don't know much about one another or about the environment they exist in.

Being are contained within Groups. A Group is pretty much just an alias for a Collection of Beings. However, one of the few things Beings do know is what groups they are contained in. This is needed for easy deletion when Beings need to be destroyed (for example, when characters die).

Beings are governed by Environments and Interactors. An Environment is a child of Group, and is used for updating beings. Updating an environment simply applies an update sequentially to all contained beings. For example, this can be used to apply a uniform downward force of gravity, or friction. Environments can be bounded spatially to filter the beings within them, for example a game level could have both air and water areas, with different laws of physics.

Interactors govern relationships between beings. An interactor is a parametrized interface with two methods: detect and handle. Detect simply determines if two being should interact, and handle applies the results of the interaction. This can be applied to a wide variety of situations. For example, it could be used for a general force calculation as in Galaxy, or for collision detection and response, or for something more specific like character X steps on pad Y, causing door Z to open. Interactors will be the main way to set conditional rules for the game.

The whole game state is governed by the World class. The World keeps track of all of the beings and runs the main loop, checking for and handling interactions. World has a registerInteraction method that allows the user to register groups of interacting beings for checking. The order in which they register will determine the order of checking. Once they have set up all their interactions and environment, they can simply call World.run() and we will handle all of the updating for them. Or they can choose to override our updating method and handle the loop themself.

To speed up interaction handling, we have an interface called Optimizer, which prevents O(n^2) interaction checking. The Optimizer performs some operation that sorts Beings in such a way that their interaction can be checked in an optimized manner, for example building a quadtree or sorting Being by the room or board area they occupy. This structure is used to detect many interactions at a time, preventing inefficient calculations.

All of this happens (literally) under God. God is basically a singleton object that sets whichever world the game is currently playing in, handles transitions between worlds, and deals with global drawing effects. World updating runs on its own thread (separate from the graphics thread).

